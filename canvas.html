<html>
<head>
<script src="d3.v4.min.js"></script>
<script src="d3-geo-projection.v2.min.js"></script>
<style>
  svg, canvas {
    position: absolute;
    top: 0;
    left: 0;
  }
  .arcs path {
    display: none;
  }
  circle {
    fill: #8cb4ff;
  }
</style>
</head>
<body>


<script>

var width = 1400;
var height = 700;
var base = d3.select('body').append('svg')
  .attr('width', width)
  .attr('height', height);
var canvas = d3.select('body')
  .append('canvas')
  .attr('width', width)
  .attr('height', height);
var ctx = canvas.node().getContext('2d');
ctx.strokeStyle = 'rgba(0,150,200,.4)';
ctx.lineWidth = 1;
ctx.fillStyle = 'rgb(31, 31, 41)';
var svg = d3.select('body').append('svg')
	.attr('width', width)
	.attr('height', height);

var filter = svg.append('defs')
  .append('filter')
  .attr('id', 'glow');

filter.append('feGaussianBlur')
  .attr('stdDeviation', 2.5)
  .attr('result', 'coloredBlur');
var merge = filter.append('feMerge');
merge.append('feMergeNode').attr('in', 'coloredBlur');
merge.append('feMergeNode').attr('in', 'SourceGraphic');

var projection = d3.geoRobinson()
  .scale(200)
	.translate([width/2, height/2]);
var path = d3.geoPath()
	.projection(projection);

var path2 = d3.geoPath()
  .projection(projection)
  .context(ctx);
path2({type:'Sphere'});
ctx.fill();

base.append('path')
  .datum({type:'Sphere'})
  .style('fill', 'rgb(31, 31, 41)')
  .attr('d', path);

var land = svg.append('g');
var arcs = svg.append('g').attr('class', 'arcs');//.attr('filter', 'url(#glow)');
var bigDots = svg.append('g').style('opacity',0);
var dots = svg.append('g').style('opacity', .1);

var arcData;

var colors = {
	'Africa': '#fccde5',
	'Asia': '#b3de69',
	'North America': '#80b1d3',
	'South America': '#fdb462',
	'Europe': '#ccc',
	'Antarctica': '#8dd3c7',
	'Oceania': '#ffffb3'

}

d3.json('countries.geojson', function (json) {
	land.selectAll('path')
		.data(json.features)
		.enter()
		.append('path')
		.style('fill', '#333')
		.style('stroke', '#111')
    .style('stroke-width', 0.5)
		.attr('d', path)
    .on('click', function (d) {
      drawCountryArcs(d.properties.name)
    })
});

var countries = [];


d3.json('arcs2.json', function (error, json) {
  //console.log(error, json)
  arcData = json;
  arcData.forEach(function(d) {
    if (d[1] && countries.indexOf(d[1]) == -1) countries.push(d[1]);
  })
  dots.selectAll('circle')
    .data(arcData)
    .enter()
    .append('circle')
    .attr('r',3)
    .attr('cx', function(d){
      return projection(d[0][0][0])[0];
    })
    .attr('cy', function(d){
      return projection(d[0][0][0])[1];
    })
    .on('mouseover touchstart touchmove', function(d){
      drawArc(d);
    });

  bigDots.selectAll('circle')
    .data(arcData)
    .enter()
    .append('circle')
    .attr('r',7)
    .attr('cx', function(d){
      return projection(d[0][0][0])[0];
    })
    .attr('cy', function(d){
      return projection(d[0][0][0])[1];
    })
    .on('mouseover', function(d){
      drawArc(d);
    });
	// arcs.selectAll('path')
	// 	.data(json.features)
	// 	.enter()
	// 	.append('path')
	// 	.style('fill', 'none')
	// 	.style('stroke', '#999')
	// 	//.attr('stroke-dasharray', '50, 2000')
	// 	//.attr('stroke-dashoffset', '-100')
	// 	.style('opacity', 0.5)
	// 	.attr('d', path);
});

var dashLength = 10;

var paths = [];

function drawArc (d, pxPerSec) {
  var geom = d[0];

  var line0 = {type:'LineString', coordinates: geom[0]};
  var line1;
  if (geom[1]) {
    line1 = {type:'LineString', coordinates: geom[1]};
  }
  var arc0 = arcs.append('path')
    .datum(line0)
    .attr('d', path)

  var pathObject = {d: d, color: colors[d[4]], datum: line0, path: arc0.node(), length: arc0.node().getTotalLength(), current: 0};

  //path2(line0);

  if (geom[1]) {
    line1 = {type:'LineString', coordinates: geom[1]};
    var arc1 = arcs.append('path')
      .datum(line1)
      .attr('d', path);
    pathObject.next = {d: d, color: colors[d[4]], datum: line1, path: arc1.node(), length: arc1.node().getTotalLength(), logit: true, current: 0, callback: function () {
        arc0.remove();
        arc1.remove();
    }};
    //path2(line1);
  } else {
    pathObject.callback = function () {
      arc0.remove();
    }
  }
  paths.push(pathObject);
  ctx.stroke();
}

function drawCountryArcs (countryName) {
  var points = arcData
    .filter(function (d) {
      return d[1] == countryName;
    })
    .forEach(function(d){
      drawArc(d, 300)
    });
}

function drawContinentArcs (continentName) {
  var points = arcData
    .filter(function (d) {
      return d[2] == continentName;
    })
    .forEach(function(d){
      drawArc(d, 300)
    });
}

var interval;
function drawRandom () {
  interval = setInterval(function () {
    var i = Math.floor(Math.random() * arcData.length);
    drawArc(arcData[i]);
    var i2 = Math.floor(Math.random() * arcData.length);
    drawArc(arcData[i2]);
    var i3 = Math.floor(Math.random() * arcData.length);
    drawArc(arcData[i3]);
  }, 5);
}

function stop () {
  clearInterval(interval);
}

setInterval(drawFrame, 20);

//window.requestAnimationFrame(drawFrame);

// var path2 = d3.geoPath();
// path2.context(bufferContext());

var clearMap = false;
var step = 5;

function drawFrame () {
  if (!paths.length) {
    // if (clearMap) {
    //   path2({type:'Sphere'});
    //   ctx.fill();
    //   clearMap = false;
    //   ctx.save();
    //   ctx.globalCompositeOperation = 'destination-out';
    //   ctx.globalAlpha = 0.1;
    //   ctx.fillRect(0,0,width,height);
    //   ctx.restore();
    // }
    //window.requestAnimationFrame(drawFrame);
    //return;
  }
  // ctx.beginPath();
  // path2({type:'Sphere'});
  // ctx.fill();
  
  ctx.save();
  ctx.globalCompositeOperation = 'destination-out';
  ctx.globalAlpha = 0.1;
  ctx.fillRect(0,0,width,height);
  ctx.restore();

  var toAppend = [];
  var toRemove = [];

  ctx.beginPath();

  var colorGroups = {};
  paths.forEach(function(p, i) {
    p.index = i;
    if (!colorGroups[p.color]) {
      colorGroups[p.color]  = [];
    }
    colorGroups[p.color].push(p);
  });

  for (var color in colorGroups) {
    ctx.beginPath();
    var group = colorGroups[color];
    group.forEach(function(p, i) {
      // if (p.logit){
      //   console.log(p.current, p.length)
      // }
      if (p.current >= p.length || p.length == 0){
        toRemove.push(p.index);
        if (p.next) {
          toAppend.push(p.next);
        } else if (p.callback) {
          p.callback();
        }
      } else if (p.current < p.length) {
        var pt0 = p.path.getPointAtLength(p.current);
        var pt1 = p.path.getPointAtLength(Math.min(p.length, p.current + step));
        if (Math.abs(pt1.x - pt0.x) > 100) {
          // something is jacked up; quit this line
          if (p.next) {
            toAppend.push(p.next);
          } else if (p.callback) {
            p.callback();
          }
          return;
        }
        ctx.moveTo(pt0.x, pt0.y);
        ctx.lineTo(pt1.x, pt1.y);
      } 
      p.current += step;
    });
    ctx.strokeStyle = color;
    ctx.stroke();
  };

  if (toRemove.length) {
    toRemove.sort(function(a,b){ return b-a; });
    for (var n = 0; n < toRemove.length; n++) {
      paths.splice(toRemove[n], 1);
    }
  }
  if (toAppend.length) {
    paths = paths.concat(toAppend);
  }
 // window.requestAnimationFrame(drawFrame);
}


function bufferContext() {
  var buffer = [];
  return {
    moveTo: function(x, y) { buffer.push([x, y]); },
    lineTo: function(x, y) { buffer.push([x, y]); },
    closePath: function() {},
    buffer: function() { var _ = buffer; buffer = []; return _; }
  };
}

</script>
</body>